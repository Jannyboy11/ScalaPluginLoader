package xyz.janboerman.scalaloader.example.scala

import org.bukkit.ChatColor

import java.io.File
import org.bukkit.configuration.file.YamlConfiguration
import xyz.janboerman.scalaloader.configurationserializable.Scan.IncludeProperty
import xyz.janboerman.scalaloader.configurationserializable.{ConfigurationSerializable, DelegateSerialization, Scan}

import scala.collection.mutable

object SerializationTest {

    private val dataFolder = ExamplePlugin.getDataFolder;
    dataFolder.mkdirs();
    private val saveFile = new File(dataFolder, "serialization-test.yml");

    if (!saveFile.exists()) saveFile.createNewFile()

    def test(): Unit = {
        val console = ExamplePlugin.getServer.getConsoleSender
        console.sendMessage(s"${ChatColor.YELLOW}Test ${ChatColor.RESET}case class/methods/fields value.equals(deserialize(serialize(value))")

        val writeConfiguration = new YamlConfiguration();

        val caseTest = CaseSerializationTest("case", 1337)
        val methodTest = new MethodsSerializationTest("methods", 1338)
        val fieldTest = new FieldsSerializationTest("fields", 1339)

        writeConfiguration.set("case", caseTest)
        writeConfiguration.set("methods", methodTest)
        writeConfiguration.set("fields", fieldTest)
        writeConfiguration.save(saveFile)

        val readConfiguration = YamlConfiguration.loadConfiguration(saveFile)
        val caseSerializationTest = readConfiguration.get("case")
        val methodsSerializationTest = readConfiguration.get("methods")
        val fieldsSerializationTest = readConfiguration.get("fields")

        assert(caseTest == caseSerializationTest);
        assert(methodTest == methodsSerializationTest)
        assert(fieldTest == fieldsSerializationTest)
        if (ExamplePlugin.assertionsEnabled()) {
            console.sendMessage(s"${ChatColor.GREEN}Test passed!")
        }

        Maybe.test()
    }
}

@ConfigurationSerializable(as = "CaseSerializationTest", scan = new Scan(value = Scan.Type.CASE_CLASS))
case class CaseSerializationTest(name: String, count: Int)

@ConfigurationSerializable(as = "MethodsSerializationTest", scan = new Scan(value = Scan.Type.GETTER_SETTER_METHODS))
class MethodsSerializationTest(private var name: String, private var count: Int) {

    @IncludeProperty def getName(): String = name
    @IncludeProperty def setName(name: String): Unit = this.name = name

    @IncludeProperty("amount") def getCount(): Int = count
    @IncludeProperty("amount") def setCount(count: Int): Unit = this.count = count

    override def toString(): String = s"MethodsSerializableTest($name,$count)"

    override def equals(obj: Any): Boolean = {
        obj match {
            case mst: MethodsSerializationTest => this.getName() == mst.getName() && this.getCount() == mst.getCount()
            case _ => false
        }
    }

    override def hashCode(): Int = java.util.Objects.hash(getName(), getCount())

}

@ConfigurationSerializable(as = "FieldsSerializationTest", scan = new Scan(value = Scan.Type.FIELDS))
class FieldsSerializationTest private(private var name: String) {

    @IncludeProperty("amount") var count: Int = 0

    def this(name: String, count: Int) = {
        this(name)
        this.count = count
    }

    override def toString(): String = s"FieldsSerializationTest($name, $count)"

    override def equals(obj: Any): Boolean = {
        obj match {
            case fst: FieldsSerializationTest => this.name == fst.name && this.count == fst.count
            case _ => false
        }
    }

    override def hashCode(): Int = java.util.Objects.hash(name, count)
}



object Maybe {
    private val saveFile = new File(ExamplePlugin.getDataFolder, "maybe.yml")
    ExamplePlugin.getDataFolder.mkdirs()
    if (!saveFile.exists()) saveFile.createNewFile()

    def test(): Unit = {
        val console = ExamplePlugin.getServer.getConsoleSender
        console.sendMessage(s"${ChatColor.YELLOW}Test ${ChatColor.RESET}maybe.equals(deserialize(serialize(maybe))")

        val justHello = Maybe("Hello")
        val nothing = Maybe(null)

        var config = new YamlConfiguration()
        config.set("justHello", justHello)
        config.set("nothing", nothing)
        config.save(saveFile)

        config = YamlConfiguration.loadConfiguration(saveFile)
        assert(justHello == config.get("justHello"))
        assert(nothing == config.get("nothing"))
        if (ExamplePlugin.assertionsEnabled()) {
            console.sendMessage(s"${ChatColor.GREEN}Test passed!")
        }
    }

    def apply[T](value: T): Maybe[T] = if (value == null) NoValue else Just(value)


//    //generated by the classloader! (as a static method on Maybe)
//    def deserialize(map: java.util.Map[String, AnyRef]): Maybe[_] = {
//        import org.bukkit.configuration.serialization.ConfigurationSerialization
//
//        ConfigurationSerialization.deserializeObject(
//            map,
//            ConfigurationSerialization.getClassByAlias(map.get("$variant").asInstanceOf[String])
//        ).asInstanceOf[Maybe[_]]
//    }
}

@DelegateSerialization(value = Array(classOf[Just[_]], classOf[NoValue.type]), as = "Maybe")
sealed trait Maybe[+T] {
   //if we would define serialize() here, it wouldn't ever by called anyway because subclasses override it!
   //so, in the serialize methods of Just and Nothing, we need to inject an extra map.put!
}

object Just {
//    //generated by the classloader! (as a static method on Just!)
//    def deseralize(map: java.util.Map[String, AnyRef]): Just[_] = {
//        apply(map.get("value"))
//    }
}
@ConfigurationSerializable(scan = new Scan(Scan.Type.CASE_CLASS), as = "Just")
case class Just[+T](value: T) extends Maybe[T] {
//    //generated by the classloader (2nd pass, as serialize())
//    def serialize(): java.util.Map[String, AnyRef] = {
//        val map = new java.util.HashMap[String, AnyRef]()
//        map.putAll($serialize());
//        map.put("$variant", "Just" /*or the class name in case there was no alias*/)
//        map
//    }
//
//    //generated by the classloader! (1st pass, as serialize(), renamed in second pass to $serialize())
//    def $serialize(): java.util.Map[String, AnyRef] = {
//        val map = new java.util.HashMap[String, AnyRef]()
//        map.put("value", value.asInstanceOf[AnyRef])
//        map
//    }
}

@ConfigurationSerializable(scan = new Scan(Scan.Type.SINGLETON_OBJECT), as = "Nothing")
case object NoValue extends Maybe[scala.Nothing] {
//    //generated by the classloader (2nd pass, as serialize())
//    def serialize(): java.util.Map[String, AnyRef] = {
//        val map = new java.util.HashMap[String, AnyRef]()
//        map.putAll($serialize())
//        map.put("$variant", "Nothing" /*or or the class name in case there was no alias*/)
//        return map;
//    }
//
//    //generated by the classloader (but static)!
//    def deserialize(map: java.util.Map[String, AnyRef]): Nothing.type = {
//        Nothing
//    }
//
//    //generated by the classloader! (1st pass, as serialize(), renamed in second pass to serialize$()
//    def $serialize(): java.util.Map[String, AnyRef] = {
//        val map = new java.util.HashMap[String, AnyRef]()
//        map
//    }
}

//@ConfigurationSerializable
class ImmutableCollectionTest {
    import scala.collection.immutable._

    private val cons: ::[String] = ::("foo", Nil)
    private val nil: Nil.type = Nil;
    private val list: List[Long] = List(0L, 1L, 2L)
    private val seq: Seq[Byte] = Seq(127.asInstanceOf[Byte])
    private val arraySeq: ArraySeq[Boolean] = ArraySeq(false, true)
    private val bitSet: BitSet = BitSet(0x0, 0x1, 0x2, 0x4)
    private val hashMap: HashMap[Short, Float] = HashMap(5.asInstanceOf[Short] -> 5F)
    private val hashSet: HashSet[String] = HashSet("hello", "world")
    private val indexedSeq: IndexedSeq[Double] = IndexedSeq(0D, 1D, 2D, 3D)
    private val intMap: IntMap[String] = IntMap(5 -> "bar", 6 -> "quz")
    private val lazyList: LazyList[Char] = LazyList('a', 'b', 'c')
    private val linearSeq: LinearSeq[Int] = LinearSeq(42, 43, 44)
    private val listSet: ListSet[Int] = ListSet(1, 2, 3)
    private val longMap: LongMap[Long] = LongMap(0L -> 1L, 1L -> 2L, 2L -> 3L)
    private val map: Map[Int, String] = Map(0 -> "scala", 1 -> "is", 2 -> "cool")
    private val numericRange: NumericRange[Long] = NumericRange.apply(0L, 10L, 1L)
    private val queue: Queue[String] = Queue("6", "7", "8")
    private val range: Range = Range.inclusive(0, 10)
    private val seqMap: SeqMap[Int, Float] = SeqMap(1 -> 1F, 2 -> 2F)
    private val set: Set[Int] = Set(5, 6, 7, 8, 9)
    private val sortedMap: SortedMap[Int, Double] = SortedMap(3 -> 3D, 4 -> 4D)
    private val sortedSet: SortedSet[String] = SortedSet("the", "meaning", "of", "life")
    private val treeMap: TreeMap[String, Boolean] = TreeMap("is" -> false, "42" -> true)
    private val treeSeqMap: TreeSeqMap[Char, Int] = TreeSeqMap('x' -> 24, 'y' -> 25, 'z' -> 26)
    private val treeSet: TreeSet[String] = TreeSet("java", "is", "also", "cool")
    private val vector: Vector[Int] = Vector(10, 11, 12)
    private val vectorMap: VectorMap[Int, String] = VectorMap(51 -> "51")
    private val wrappedString: WrappedString = new WrappedString("Hello, World!")

}

class MutableCollectionTest {
    import scala.collection.mutable._

    private val arrayBuffer: ArrayBuffer[String] = new ArrayBuffer();
    private val arrayDeque: ArrayDeque[String] = new ArrayDeque();
    private val arraySeq: ArraySeq[String] = new ArraySeq.ofRef[String](Array[String]())   //there are 'overloads' for all primitive types and unit
    private val bitSet: BitSet = new BitSet();
    private val buffer: Buffer[String] = new ArrayBuffer()
    private val collisionProofHashMap: CollisionProofHashMap[String, String] = new mutable.CollisionProofHashMap()
    private val hashMap: HashMap[String, String] = new HashMap()
    private val hashSet: HashSet[String] = new HashSet()
    private val linkedHashMap: LinkedHashMap[String, String] = new LinkedHashMap()
    private val linkedHashSet: LinkedHashSet[String] = new LinkedHashSet()
    private val listBuffer: ListBuffer[String] = new ListBuffer()
    private val longMap: LongMap[String] = new LongMap()
    private val map: Map[String, String] = new HashMap()
    private val priorityQueue: PriorityQueue[String] = new PriorityQueue[String]()
    private val queue: Queue[String] = new Queue()
    private val seq: Seq[String] = new ListBuffer[String]
    private val seqMap: SeqMap[String, String] = new LinkedHashMap()
    private val set: Set[String] = new LinkedHashSet[String]()
    private val sortedMap: SortedMap[String, String] = new TreeMap()
    private val sortedSet: SortedSet[String] = new TreeSet()
    private val stack: Stack[String] = new Stack()
    private val treeMap: TreeMap[String, String] = new TreeMap()
    private val treeSet: TreeSet[String] = new TreeSet()
    private val unrolledBuffer: UnrolledBuffer[String] = new UnrolledBuffer()
    private val weakHashMap: WeakHashMap[String, String] = new WeakHashMap()

}

class OtherTest {

    private val some: Some[String] = Some("Hi!")
    private val none: None.type = None
    private val left: Either[String, String] = Left("Hello!")
    private val right: Either[String, String] = Right("World!")
    private val unit: Unit = ()
    private val NULL: Null = null;
    private val tuple1 = new Tuple1("a")
    private val tuple2 = new Tuple2("a", "b")
    private val tuple3 = new Tuple3("a", "b", "c")
    private val tuple4 = new Tuple4("a", "b", "c", "d")
    private val tuple5 = new Tuple5("a", "b", "c", "d", "e")
    private val tuple6 = new Tuple6("a", "b", "c", "d", "e", "f")
    private val tuple7 = new Tuple7("a", "b", "c", "d", "e", "f", "g")
    private val tuple8 = new Tuple8("a", "b", "c", "d", "e", "f", "g", "h")
    private val tuple9 = new Tuple9("a", "b", "c", "d", "e", "f", "g", "h", "i")
    private val tuple10 = new Tuple10("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")
    private val tuple11 = new Tuple11("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k")
    private val tuple12 = new Tuple12("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l")
    private val tuple13 = new Tuple13("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m")
    private val tuple14 = new Tuple14("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n")
    private val tuple15 = new Tuple15("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o")
    private val tuple16 = new Tuple16("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p")
    private val tuple17 = new Tuple17("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q")
    private val tuple18 = new Tuple18("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r")
    private val tuple19 = new Tuple19("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s")
    private val tuple20 = new Tuple20("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t")
    private val tuple21 = new Tuple21("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u")
    private val tuple22 = new Tuple22("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v")


}