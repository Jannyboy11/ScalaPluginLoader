package xyz.janboerman.scalaloader.example.scala

import org.bukkit.ChatColor

import java.io.File
import org.bukkit.configuration.file.YamlConfiguration
import xyz.janboerman.scalaloader.configurationserializable.Scan.IncludeProperty
import xyz.janboerman.scalaloader.configurationserializable.{ConfigurationSerializable, DelegateSerialization, Scan}

object SerializationMethodsTest {

    private val dataFolder = ExamplePlugin.getDataFolder;
    dataFolder.mkdirs();
    private val saveFile = new File(dataFolder, "serialization-test.yml");

    if (!saveFile.exists()) saveFile.createNewFile()

    def test(): Unit = {
        val console = ExamplePlugin.getServer.getConsoleSender
        console.sendMessage(s"${ChatColor.YELLOW}Test ${ChatColor.RESET}case class/methods/fields value.equals(deserialize(serialize(value))")

        val writeConfiguration = new YamlConfiguration();

        val caseTest = CaseSerializationTest("case", 1337)
        val methodTest = new MethodsSerializationTest("methods", 1338)
        val fieldTest = new FieldsSerializationTest("fields", 1339)

        writeConfiguration.set("case", caseTest)
        writeConfiguration.set("methods", methodTest)
        writeConfiguration.set("fields", fieldTest)
        writeConfiguration.save(saveFile)

        val readConfiguration = YamlConfiguration.loadConfiguration(saveFile)
        val caseSerializationTest = readConfiguration.get("case")
        val methodsSerializationTest = readConfiguration.get("methods")
        val fieldsSerializationTest = readConfiguration.get("fields")

        assert(caseTest == caseSerializationTest);
        assert(methodTest == methodsSerializationTest)
        assert(fieldTest == fieldsSerializationTest)
        if (ExamplePlugin.assertionsEnabled()) {
            console.sendMessage(s"${ChatColor.GREEN}Test passed!")
        }

        Maybe.test()
    }
}

@ConfigurationSerializable(as = "CaseSerializationTest", scan = new Scan(value = Scan.Type.CASE_CLASS))
case class CaseSerializationTest(name: String, count: Int)

@ConfigurationSerializable(as = "MethodsSerializationTest", scan = new Scan(value = Scan.Type.GETTER_SETTER_METHODS))
class MethodsSerializationTest(private var name: String, private var count: Int) {

    @IncludeProperty def getName(): String = name
    @IncludeProperty def setName(name: String): Unit = this.name = name

    @IncludeProperty("amount") def getCount(): Int = count
    @IncludeProperty("amount") def setCount(count: Int): Unit = this.count = count

    override def toString(): String = s"MethodsSerializableTest($name,$count)"

    override def equals(obj: Any): Boolean = {
        obj match {
            case mst: MethodsSerializationTest => this.getName() == mst.getName() && this.getCount() == mst.getCount()
            case _ => false
        }
    }

    override def hashCode(): Int = java.util.Objects.hash(getName(), getCount())

}

@ConfigurationSerializable(as = "FieldsSerializationTest", scan = new Scan(value = Scan.Type.FIELDS))
class FieldsSerializationTest private(private var name: String) {

    @IncludeProperty("amount") var count: Int = 0

    def this(name: String, count: Int) = {
        this(name)
        this.count = count
    }

    override def toString(): String = s"FieldsSerializationTest($name, $count)"

    override def equals(obj: Any): Boolean = {
        obj match {
            case fst: FieldsSerializationTest => this.name == fst.name && this.count == fst.count
            case _ => false
        }
    }

    override def hashCode(): Int = java.util.Objects.hash(name, count)
}



object Maybe {
    private val saveFile = new File(ExamplePlugin.getDataFolder, "maybe.yml")
    ExamplePlugin.getDataFolder.mkdirs()
    if (!saveFile.exists()) saveFile.createNewFile()

    def test(): Unit = {
        val console = ExamplePlugin.getServer.getConsoleSender
        console.sendMessage(s"${ChatColor.YELLOW}Test ${ChatColor.RESET}maybe.equals(deserialize(serialize(maybe))")

        val justHello = Maybe("Hello")
        val nothing = Maybe(null)

        var config = new YamlConfiguration()
        config.set("justHello", justHello)
        config.set("nothing", nothing)
        config.save(saveFile)

        config = YamlConfiguration.loadConfiguration(saveFile)
        assert(justHello == config.get("justHello"))
        assert(nothing == config.get("nothing"))
        if (ExamplePlugin.assertionsEnabled()) {
            console.sendMessage(s"${ChatColor.GREEN}Test passed!")
        }
    }

    def apply[T](value: T): Maybe[T] = if (value == null) NoValue else Just(value)


//    //generated by the classloader! (as a static method on Maybe)
//    def deserialize(map: java.util.Map[String, AnyRef]): Maybe[_] = {
//        import org.bukkit.configuration.serialization.ConfigurationSerialization
//
//        ConfigurationSerialization.deserializeObject(
//            map,
//            ConfigurationSerialization.getClassByAlias(map.get("$variant").asInstanceOf[String])
//        ).asInstanceOf[Maybe[_]]
//    }
}

@DelegateSerialization(value = Array(classOf[Just[_]], classOf[NoValue.type]), as = "Maybe")
sealed trait Maybe[+T] {
   //if we would define serialize() here, it wouldn't ever by called anyway because subclasses override it!
   //so, in the serialize methods of Just and Nothing, we need to inject an extra map.put!
}

object Just {
//    //generated by the classloader! (as a static method on Just!)
//    def deseralize(map: java.util.Map[String, AnyRef]): Just[_] = {
//        apply(map.get("value"))
//    }
}
@ConfigurationSerializable(scan = new Scan(Scan.Type.CASE_CLASS), as = "Just")
case class Just[+T](value: T) extends Maybe[T] {
//    //generated by the classloader (2nd pass, as serialize())
//    def serialize(): java.util.Map[String, AnyRef] = {
//        val map = new java.util.HashMap[String, AnyRef]()
//        map.putAll($serialize());
//        map.put("$variant", "Just" /*or the class name in case there was no alias*/)
//        map
//    }
//
//    //generated by the classloader! (1st pass, as serialize(), renamed in second pass to $serialize())
//    def $serialize(): java.util.Map[String, AnyRef] = {
//        val map = new java.util.HashMap[String, AnyRef]()
//        map.put("value", value.asInstanceOf[AnyRef])
//        map
//    }
}

@ConfigurationSerializable(scan = new Scan(Scan.Type.SINGLETON_OBJECT), as = "Nothing")
case object NoValue extends Maybe[scala.Nothing] {
//    //generated by the classloader (2nd pass, as serialize())
//    def serialize(): java.util.Map[String, AnyRef] = {
//        val map = new java.util.HashMap[String, AnyRef]()
//        map.putAll($serialize())
//        map.put("$variant", "Nothing" /*or or the class name in case there was no alias*/)
//        return map;
//    }
//
//    //generated by the classloader (but static)!
//    def deserialize(map: java.util.Map[String, AnyRef]): Nothing.type = {
//        Nothing
//    }
//
//    //generated by the classloader! (1st pass, as serialize(), renamed in second pass to serialize$()
//    def $serialize(): java.util.Map[String, AnyRef] = {
//        val map = new java.util.HashMap[String, AnyRef]()
//        map
//    }
}


object ScalaTypesSerializationTest {

    def test(): Unit = {
        //TODO turns out the scala compiler does not output correct signatures in the bytecode.
        //TODO all type arguments that are primitives seem to be of type java/lang/Object.
        //TODO that is very unfortunate. In order to get the type parameter info we need to analyze the pickles in the bytecode. hurray!
        //TODO by that I mean the @ScalaSignature annotation and the ScalaSig attribute.
        //TODO the ScalaInlineInfo attribute can probably be ignored.
        //TODO For Scala 3 this effort will need to be re-done.. because of the compiler no longer outputting pickles, but it outputs TASTy instead.
        //TODO thanks Scala! (not!)
        //TODO I think a good starting point is to look at how scalap does this!
        val immutableCollectionTest = new ImmutableCollectionTest()
        val mutableCollectionTest = new MutableCollectionTest()
        val concurrentCollectionTest = new ConcurrentCollectionTest()
        val otherTest = new OtherScalaTypesTest()

        java.lang.Class.forName("xyz.janboerman.scalaloader.example.scala.ImmutableCollectionTest$")
        java.lang.Class.forName("xyz.janboerman.scalaloader.example.scala.MutableCollectionTest$")

        import scala.reflect.ClassTag
        implicitly[ClassTag[Byte]]
        implicitly[ClassTag[Short]]
        implicitly[ClassTag[Int]]
        implicitly[ClassTag[Long]]
        implicitly[ClassTag[Float]]
        implicitly[ClassTag[Double]]
        implicitly[ClassTag[Char]]
        implicitly[ClassTag[Boolean]]
        implicitly[ClassTag[Unit]]
        implicitly[ClassTag[Nothing]]
        implicitly[ClassTag[Null]]
        implicitly[ClassTag[Any]]
        implicitly[ClassTag[AnyRef]]
        implicitly[ClassTag[AnyVal]]
        implicitly[ClassTag[java.lang.Object]]
        implicitly[ClassTag[java.lang.String]]

        //TODO on a different thought: could a Scala 3 compiler plugin work to get this type information?
        //TODO I may not have to generate bytecode at class-load time at all in that case, but just transform the AST in the plugin compiler phase!
    }

}


//@ConfigurationSerializable
class ImmutableCollectionTest {
    import scala.collection.immutable._
    import scala.collection.JavaConverters
    import xyz.janboerman.scalaloader.configurationserializable.runtime.{NumericRange => SLRange}

    private var list: List[Long] = List(0L, 1L, 2L)
    private var seq: Seq[Byte] = Seq(127.asInstanceOf[Byte])
    private var arraySeq: ArraySeq[Boolean] = ArraySeq(false, true)
    private var bitSet: BitSet = BitSet(0x0, 0x1, 0x2, 0x4)
    private var hashMap: HashMap[Short, Float] = HashMap(5.asInstanceOf[Short] -> 5F)
    private var hashSet: HashSet[String] = HashSet("hello", "world")
    private var indexedSeq: IndexedSeq[Double] = IndexedSeq(0D, 1D, 2D, 3D)
    private var intMap: IntMap[String] = IntMap(5 -> "bar", 6 -> "quz")
    private var lazyList: LazyList[Char] = LazyList('a', 'b', 'c')
    private var linearSeq: LinearSeq[Int] = LinearSeq(42, 43, 44)
    private var listSet: ListSet[Int] = ListSet(1, 2, 3)
    private var longMap: LongMap[Long] = LongMap(0L -> 1L, 1L -> 2L, 2L -> 3L)
    private var map: Map[Int, String] = Map(0 -> "scala", 1 -> "is", 2 -> "cool")
    private var numericRange: NumericRange[Long] = NumericRange.apply(0L, 10L, 1L)
    private var queue: Queue[String] = Queue("6", "7", "8")
    private var range: Range = Range.inclusive(0, 10)
    private var seqMap: SeqMap[Int, Float] = SeqMap(1 -> 1F, 2 -> 2F)
    private var set: Set[Int] = Set(5, 6, 7, 8, 9)
    private var sortedMap: SortedMap[Int, Double] = SortedMap(3 -> 3D, 4 -> 4D)
    private var sortedSet: SortedSet[String] = SortedSet("the", "meaning", "of", "life")
    private var treeMap: TreeMap[String, Boolean] = TreeMap("is" -> false, "42" -> true)
    private var treeSeqMap: TreeSeqMap[Char, Int] = TreeSeqMap('x' -> 24, 'y' -> 25, 'z' -> 26)
    private var treeSet: TreeSet[String] = TreeSet("java", "is", "also", "cool")
    private var vector: Vector[Int] = Vector(10, 11, 12)
    private var vectorMap: VectorMap[Int, String] = VectorMap(51 -> "51")
    private var wrappedString: WrappedString = new WrappedString("Hello, World!")

    def serialize(): java.util.Map[String, AnyRef] = {
        val result = new java.util.LinkedHashMap[String, AnyRef]()

        //TODO this is going to be fun. depending on the version of Scala used by the plugin,
        //TODO I need to pick the right conversion method. Thanks Scala! (not!)
        //TODO I could make use of ScalaRelease?

        //use a java.util.LinkedHashSet if the scala collection type is known to be a Set

        val javaList = new java.util.ArrayList[Long]()
        val listIterator: Iterator[Long] = list.iterator
        while (listIterator.hasNext) {
            javaList.add(/*serialize(*/listIterator.next()/*)*/)
        }

        result.put("list", javaList)


//        result.put("seq", JavaConverters.asJava(seq))
//        result.put("arraySeq", JavaConverters.asJava(arraySeq))
//        result.put("bitSet", JavaConverters.asJava(bitSet))
//        result.put("hashMap", JavaConverters.asJava(hashMap))
//        result.put("hashSet", JavaConverters.asJava(hashSet))
//        result.put("indexedSeq", JavaConverters.asJava(indexedSeq))
//        result.put("intMap", JavaConverters.asJava(intMap))
//        result.put("lazyList", JavaConverters.asJava(lazyList))
//        result.put("linearSeq", JavaConverters.asJava(linearSeq))
//        result.put("listSet", JavaConverters.asJava(listSet))
//        result.put("longMap", JavaConverters.asJava(longMap))
//        result.put("map", JavaConverters.asJava(map))
//        result.put("numericRange", new SLRange.OfLong(numericRange.start, numericRange.step, numericRange.end, numericRange.isInclusive))
//        result.put("queue", JavaConverters.asJava(queue))
//        result.put("range", new SLRange.OfInteger(range.start, range.step, range.end, range.isInclusive))
//        result.put("seqMap", JavaConverters.asJava(seqMap))
//        result.put("set", JavaConverters.asJava(set));
//        result.put("sortedMap", JavaConverters.asJava(sortedMap))
//        result.put("sortedSet", JavaConverters.asJava(sortedSet))
//        result.put("treeMap", JavaConverters.asJava(treeMap))
//        result.put("treeSeqMap", JavaConverters.asJava(treeSeqMap))
//        result.put("treeSet", JavaConverters.asJava(treeSet))
//        result.put("vector", JavaConverters.asJava(vector))
//        result.put("vectorMap", JavaConverters.asJava(vectorMap))
//        result.put("wrappedString", wrappedString.toString())

        result
    }
}

object ImmutableCollectionTest {
    import scala.collection.immutable._
    import xyz.janboerman.scalaloader.configurationserializable.runtime.{NumericRange => SLRange}

    def deserialize(map: java.util.Map[String, AnyRef]): ImmutableCollectionTest = {
        val res = new ImmutableCollectionTest()

        val list = map.get("list").asInstanceOf[java.util.List[Long]]
        val scalaListBuilder = List.newBuilder[Long]
        val javaListIterator = list.iterator()
        while (javaListIterator.hasNext) {
            scalaListBuilder.addOne(/*serialize(*/javaListIterator.next()/*)*/)
        }
        res.list = scalaListBuilder.result()

        //TODO scala.collection.immutable.ArraySeq$.newBuilder[T] requires an implicit ClassTag[T]
        //TODO create this ClassTag from the first type argument from the TypeSignature!
        //TODO should be doable given this api! https://www.scala-lang.org/api/2.12.13/scala/reflect/ClassTag$.html
        //TODO it seems to be quite stable too: https://www.scala-lang.org/api/2.13.5/scala/reflect/ClassTag$.html
        //TODO unchanged in Scala 3 :)        : https://dotty.epfl.ch/api/scala/reflect/ClassTag$.html

        val arraySeq = map.get("arraySeq").asInstanceOf[java.util.List[Boolean]]
        val scalaArraySeqBuilder = ArraySeq.newBuilder[Boolean]
        /*
        GETSTATIC scala/collection/immutable/ArraySeq$.MODULE$ : Lscala/collection/immutable/ArraySeq$;
        GETSTATIC scala/reflect/ClassTag$.MODULE$ : Lscala/reflect/ClassTag$;
        INVOKEVIRTUAL scala/reflect/ClassTag$.Boolean ()Lscala/reflect/ManifestFactory$BooleanManifest;
        INVOKEVIRTUAL scala/collection/immutable/ArraySeq$.newBuilder (Lscala/reflect/ClassTag;)Lscala/collection/mutable/Builder;

        TODO what is the type descriptor for the other primitives? what is it for references? I should probably just special-case all of the special cases..
        TODO that includes all primitives, scala.Null, scala.Nothing, scala.Any, scala.AnyRef, scala.AnyVal, scala.Unit and java.lang.Object
         */
        val javaArraySeqIterator = arraySeq.iterator()
        while (javaArraySeqIterator.hasNext) {
            scalaArraySeqBuilder.addOne(/*serialize(*/javaArraySeqIterator.next()/*)*/)
        }
        res.arraySeq = scalaArraySeqBuilder.result()


//        val list = map.get("list").asInstanceOf[java.util.List[Long]]
//        res.list = List.from(JavaConverters.asScala(list))
//
//        val seq = map.get("seq").asInstanceOf[java.util.List[Byte]]
//        res.seq = Seq.from(JavaConverters.asScala(seq))
//
//        val arraySeq = map.get("arraySeq").asInstanceOf[java.util.List[Boolean]]
//        res.arraySeq = ArraySeq.from(JavaConverters.asScala(arraySeq))
//
//        val bitSet = map.get("bitSet").asInstanceOf[java.util.Set[Int]]
//        res.bitSet = BitSet.fromSpecific(JavaConverters.asScala(bitSet))
//
//        val hashMap = map.get("hashMap").asInstanceOf[java.util.Map[Short, Float]]
//        res.hashMap = HashMap.from(JavaConverters.asScala(hashMap))
//
//        val hashSet = map.get("hashSet").asInstanceOf[java.util.Set[String]]
//        res.hashSet = HashSet.from(JavaConverters.asScala(hashSet))
//
//        val indexedSeq = map.get("indexedSeq").asInstanceOf[java.util.List[Double]]
//        res.indexedSeq = IndexedSeq.from(JavaConverters.asScala(indexedSeq))
//
//        val intMap = map.get("intMap").asInstanceOf[java.util.Map[Int, String]]
//        res.intMap = IntMap.from(JavaConverters.asScala(intMap))
//
//        val lazyList = map.get("lazyList").asInstanceOf[java.util.List[Char]]
//        res.lazyList = LazyList.from(JavaConverters.asScala(lazyList))
//
//        val linearSeq = map.get("linearSeq").asInstanceOf[java.util.List[Int]]
//        res.linearSeq = LinearSeq.from(JavaConverters.asScala(linearSeq))
//
//        val listSet = map.get("listSet").asInstanceOf[java.util.Set[Int]]
//        res.listSet = ListSet.from(JavaConverters.asScala(listSet))
//
//        val longMap = map.get("longMap").asInstanceOf[java.util.Map[Long, Long]]
//        res.longMap = LongMap.from(JavaConverters.asScala(longMap))
//
//        val m = map.get("map").asInstanceOf[java.util.Map[Int, String]]
//        res.map = Map.from(JavaConverters.asScala(m))
//
//        val numericRange = map.get("numericRange").asInstanceOf[SLRange[java.lang.Long]]
//        res.numericRange = if (numericRange.isInclusive)
//            NumericRange.inclusive(numericRange.getStart, numericRange.getEnd, numericRange.getStep)
//        else
//            NumericRange.apply(numericRange.getStart, numericRange.getEnd, numericRange.getStep)
//
//        val queue = map.get("queue").asInstanceOf[java.util.List[String]]
//        res.queue = Queue.from(JavaConverters.asScala(queue))
//
//        val range = map.get("range").asInstanceOf[SLRange[java.lang.Integer]]
//        res.range = if (range.isInclusive)
//            Range.inclusive(range.getStart, range.getEnd, range.getStep)
//        else
//            Range.apply(range.getStart, range.getEnd, range.getStep)
//
//        val seqMap = map.get("seqMap").asInstanceOf[java.util.Map[Int, Float]]
//        res.seqMap = SeqMap.from(JavaConverters.asScala(seqMap))
//
//        val set = map.get("set").asInstanceOf[java.util.Set[Int]]
//        res.set = Set.from(JavaConverters.asScala(set))
//
//        val sortedMap = map.get("sortedMap").asInstanceOf[java.util.Map[Int, Double]]
//        res.sortedMap = SortedMap.from(JavaConverters.asScala(sortedMap))
//
//        val sortedSet = map.get("sortedSet").asInstanceOf[java.util.Set[String]]
//        res.sortedSet = SortedSet.from(JavaConverters.asScala(sortedSet))
//
//        val treeMap = map.get("treeMap").asInstanceOf[java.util.Map[String, Boolean]]
//        res.treeMap = TreeMap.from(JavaConverters.asScala(treeMap))
//
//        val treeSeqMap = map.get("treeSeqMap").asInstanceOf[java.util.Map[Char, Int]]
//        res.treeSeqMap = TreeSeqMap.from(JavaConverters.asScala(treeSeqMap))
//
//        val treeSet = map.get("treeSet").asInstanceOf[java.util.Set[String]]
//        res.treeSet = TreeSet.from(JavaConverters.asScala(treeSet))
//
//        val vector = map.get("vector").asInstanceOf[java.util.List[Int]]
//        res.vector = Vector.from(JavaConverters.asScala(vector))
//
//        val vectorMap = map.get("vectorMap").asInstanceOf[java.util.Map[Int, String]]
//        res.vectorMap = VectorMap.from(JavaConverters.asScala(vectorMap))
//
//        val wrappedString = map.get("wrappedString").asInstanceOf[String]
//        res.wrappedString = new WrappedString(wrappedString)

        res
    }
}



class MutableCollectionTest {
    import scala.collection.mutable._

    //TODO need special cases for: ArrayBuilder, ArraySeq because they require an implicit ClassTag.
    //TODO I could choose to 'provide' that implicit argument (which is not implicit in the bytecode),
    //TODO or I could choose to call the constructor of the specialized subclasses directly (I think I'm going with this one!)


    private var arrayBuffer: ArrayBuffer[String] = new ArrayBuffer();
    private var arrayDeque: ArrayDeque[String] = new ArrayDeque();
    private var arraySeq: ArraySeq[String] = new ArraySeq.ofRef[String](Array[String]())   //there are 'overloads' for all primitive types and unit
    private var bitSet: BitSet = new BitSet();
    private var buffer: Buffer[String] = new ArrayBuffer()
    private var collisionProofHashMap: CollisionProofHashMap[String, String] = new CollisionProofHashMap()
    private var hashMap: HashMap[String, String] = new HashMap()
    private var hashSet: HashSet[String] = new HashSet()
    private var linkedHashMap: LinkedHashMap[String, String] = new LinkedHashMap()
    private var linkedHashSet: LinkedHashSet[String] = new LinkedHashSet()
    private var listBuffer: ListBuffer[String] = new ListBuffer()
    private var longMap: LongMap[String] = new LongMap()
    private var map: Map[String, String] = new HashMap()
    private var priorityQueue: PriorityQueue[String] = new PriorityQueue[String]()
    private var queue: Queue[String] = new Queue()
    private var seq: Seq[String] = new ListBuffer[String]
    private var seqMap: SeqMap[String, String] = new LinkedHashMap()
    private var set: Set[String] = new LinkedHashSet[String]()
    private var sortedMap: SortedMap[String, String] = new TreeMap()
    private var sortedSet: SortedSet[String] = new TreeSet()
    private var stack: Stack[String] = new Stack()
    private var treeMap: TreeMap[String, String] = new TreeMap()
    private var treeSet: TreeSet[String] = new TreeSet()
    private var unrolledBuffer: UnrolledBuffer[String] = new UnrolledBuffer()
    private var weakHashMap: WeakHashMap[String, String] = new WeakHashMap()

    def serialize(): java.util.Map[String, AnyRef] = {
        val map = new java.util.HashMap[String, AnyRef]()

        //serializing is same as for immutable collections: just use the iterator
        val java_arrayBuffer = new java.util.ArrayList[String]()
        val arrayBufferIterator = arrayBuffer.iterator
        while (arrayBufferIterator.hasNext) {
            java_arrayBuffer.add(/*serialize(*/arrayBufferIterator.next()/*)*/)
        }
        map.put("arrayBuffer", java_arrayBuffer)


        //which of the two ways of doing this would be more stable?
        //I guess the java-api way, because extensions might get implemented differently at some point in dotty.
//        map.put("arrayBuffer", arrayBuffer.asJava)
//        map.put("arrayDeque", scala.jdk.javaapi.CollectionConverters.asJava(arrayDeque))

        map
    }
}

object MutableCollectionTest {
    import scala.collection.mutable._
    import scala.jdk.CollectionConverters._

    def deserialize(map: java.util.Map[String, AnyRef]): MutableCollectionTest = {
        val result = new MutableCollectionTest()

        val java_arrayBuffer = map.get("arrayBuffer").asInstanceOf[java.util.List[String]]
        val arrayBufferBuilder = ArrayBuffer.newBuilder[String]
        val javaIterator = java_arrayBuffer.iterator()
        while (javaIterator.hasNext) {
            arrayBufferBuilder.addOne(/*deserialize(*/javaIterator.next()/*)*/)

        }
        result.arrayBuffer = arrayBufferBuilder.result()



//        val arrayBuffer = map.get("arrayBuffer").asInstanceOf[java.util.List[String]]
//        result.arrayBuffer = ArrayBuffer.from(arrayBuffer.asScala)
//
//        val arrayDeque = map.get("arrayDeque").asInstanceOf[java.util.List[String]]
//        result.arrayDeque = ArrayDeque.from(scala.jdk.javaapi.CollectionConverters.asScala(arrayDeque))

        result
    }

}

class ConcurrentCollectionTest {
    import scala.collection.concurrent.{Map, TrieMap}

    val concurrentMap = new TrieMap[String, String]()
    val trieMap = new TrieMap[String, String]()

}

class OtherScalaTypesTest {
    import scala.runtime._
    import scala.math._

    private val some: Option[String] = Some("Hi!")
    private val none: Option[String] = None
    private val left: Either[String, String] = Left("Hello!")
    private val right: Either[String, String] = Right("World!")
    private val unit: Unit = ()
    private val NULL: Null = null;

    private val richByte: RichByte = new RichByte(0.asInstanceOf[Byte])
    private val richShort: RichShort = new RichShort(0.asInstanceOf[Short])
    private val richInt: RichInt = new RichInt(0)
    private val richLong: RichLong = new RichLong(0L)
    private val richFloat: RichFloat = new RichFloat(0F)
    private val richDouble: RichDouble = new RichDouble(0D)
    private val richBoolean: RichBoolean = new RichBoolean(true)
    private val richChar: RichChar = new RichChar('a')
    private val bigInt: BigInt = new BigInt(new java.math.BigInteger("0"))
    private val bigDecimal : BigDecimal = new BigDecimal(new java.math.BigDecimal("0"))

    private val tuple1 = new Tuple1("a")
    private val tuple2 = new Tuple2("a", "b")
    private val tuple3 = new Tuple3("a", "b", "c")
    private val tuple4 = new Tuple4("a", "b", "c", "d")
    private val tuple5 = new Tuple5("a", "b", "c", "d", "e")
    private val tuple6 = new Tuple6("a", "b", "c", "d", "e", "f")
    private val tuple7 = new Tuple7("a", "b", "c", "d", "e", "f", "g")
    private val tuple8 = new Tuple8("a", "b", "c", "d", "e", "f", "g", "h")
    private val tuple9 = new Tuple9("a", "b", "c", "d", "e", "f", "g", "h", "i")
    private val tuple10 = new Tuple10("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")
    private val tuple11 = new Tuple11("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k")
    private val tuple12 = new Tuple12("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l")
    private val tuple13 = new Tuple13("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m")
    private val tuple14 = new Tuple14("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n")
    private val tuple15 = new Tuple15("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o")
    private val tuple16 = new Tuple16("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p")
    private val tuple17 = new Tuple17("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q")
    private val tuple18 = new Tuple18("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r")
    private val tuple19 = new Tuple19("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s")
    private val tuple20 = new Tuple20("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t")
    private val tuple21 = new Tuple21("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u")
    private val tuple22 = new Tuple22("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v")

}

object OrderingTest {

    //java primitives
    def byteOrder = implicitly[Ordering[Byte]]
    def shortOrder = implicitly[Ordering[Short]]
    def intOrder = implicitly[Ordering[Int]]
    def longOrder = implicitly[Ordering[Long]]
    def floatOrder = implicitly[Ordering[Float]]
    def doubleOrder = implicitly[Ordering[Double]]
    def booleanOrder = implicitly[Ordering[Boolean]]
    def charOrder = implicitly[Ordering[Char]]

    //other scala primitives
    def nullOrder = implicitly[Ordering[Null]]
    def unitOrder = implicitly[Ordering[Unit]]
    //there is no implicit for Ordering[Nothing] so, which makes sense I guess

    //other types from the Ordering companion object
    def stringOrder = implicitly[Ordering[String]](Ordering.String)
    def bigDecimalOrder = implicitly[Ordering[BigDecimal]]
    def bigIntOrder = implicitly[Ordering[BigInt]]

    //common wrappers
    def tupleOrder = implicitly[Ordering[(Long, Boolean)]]
    def optionOrder = implicitly[Ordering[Option[Char]]]
    //Either has no implicit Ordering! Didn't expect that!

    //collections
    import Ordering.Implicits._
    def intListOrder = implicitly[Ordering[List[Int]]]
    //the compiler does not seem to find the implicit. weird.
    //def sortedSetOrdering = implicitly[Ordering[scala.collection.SortedSet[Int]]]


    //comparable and comparator
    def uuidOrder = implicitly[Ordering[java.util.UUID]]
    implicit val stringComparator = String.CASE_INSENSITIVE_ORDER
    def stringCaseInsensitiveOrder = implicitly[Ordering[String]]

    //the stringComparator gets compiled to its own method (backed by a field):
    /*
        methodVisitor = classWriter.visitMethod(ACC_PUBLIC, "stringComparator", "()Ljava/util/Comparator;", "()Ljava/util/Comparator<Ljava/lang/String;>;", null);
        methodVisitor.visitCode();
        Label label0 = new Label();
        methodVisitor.visitLabel(label0);
        methodVisitor.visitLineNumber(621, label0);
        methodVisitor.visitFieldInsn(GETSTATIC, "xyz/janboerman/scalaloader/example/scala/OrderingTest$", "stringComparator", "Ljava/util/Comparator;");
        methodVisitor.visitInsn(ARETURN);
        Label label1 = new Label();
        methodVisitor.visitLabel(label1);
        methodVisitor.visitLocalVariable("this", "Lxyz/janboerman/scalaloader/example/scala/OrderingTest$;", null, label0, label1, 0);
        methodVisitor.visitMaxs(1, 1);
        methodVisitor.visitEnd();
     */

}